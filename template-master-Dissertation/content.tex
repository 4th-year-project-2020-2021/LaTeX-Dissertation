%!TEX root = project.tex

\chapter*{About this project}
\paragraph{Abstract}
Data visualisation has become popular, in part due to everyone's experience with the global pandemic Covid-19. Information is delivered in easy to understand visual representations. As this is an emerging area, the team decided to investigate different methods of data visualisation, see which performed the best for different scenarios and to develop a data visualisation application. The main focus of the application is on Covid-19, data is being generated at least daily worldwide for Covid-19. The application includes examples of other epidemics such as SARs, MERs and historic epidemics of smallpox.

\paragraph{Authors}
This project was developed as part of a fifteen credit module by Grace Keane, Jina Kim and Shirin Nagle, fourth year students of Galway Mayo Institute of Technology.

\paragraph{Acknowledgements} The authors would like to acknowledge the help and advice provided by the project supervisor Dr. John French.

\chapter{Introduction}


This chapter will outline the context, objectives and metrics for success and failure. Followed by a summary of the project and an introduction into each chapter of the dissertation and its relevance to the project.

\section{Context}
Why choose data visualisation as a subject for our Applied Project and Minor Dissertation? Towards the end of our third year in college, Ireland was shutdown and effectively put into a lockdown. All colleges, schools and areas where large amounts of people gather were closed or off limits. The reason for the lockdown was the outbreak of a disease which became known as Covid-19, a global pandemic. The first pandemic that the majority of the world's population will have ever experienced. The last global pandemic was the Spanish flu, which lasted from approximately 1918 to 1920, this pandemic occurred in three waves, though not simultaneously around the globe.\cite{Spanishflu}\\

\vspace{1mm}

The fact that our on campus learning was curtailed due to the Covid-19 outbreak has had an impact on our learning. Being software students, it was fascinating to see how much real time information was available coming from all directions. Sites like John Hopkins Dashboard tracked Covid-19's progress round the world on a daily basis. Starting off with what looked like small numbers at first, the amount of cases quickly exploded in countries like Italy and Iran, an example of exponential disease growth. If measures we not taken to halt the spread of the virus the rest of the world would eventually experience exponential growth of cases.\\

\vspace{1mm}
\section{Why Visualisation matters}

There are two useful functions for data visualisation.\\
a) The dissemination of public health information, with purpose of giving the clearest information possible to the general public.\\
b) The effective modelling, prediction and forecasting of disease trends for scientists and policy makers.

\vspace{5mm}

Exponential growth is a mathematical concept that is not properly understood by the majority of people.
"People mistakenly perceive the coronavirus to grow in a linear manner, underestimating its actual potential for exponential growth."\cite{lammers2020correcting}\\

\vspace{2mm}

“The complex data are extremely challenging for our cognitive abilities. Visual Analytics solutions may support knowledge discovery and problem solving if the needs of the different stakeholders, such as epidemiologists and environmental health specialists, are adequately addressed.”\cite{preim2020survey}

\vspace{5mm}



It struck the team that the visual representation of data is a good explanatory tool to show how fast exponential growth can happen. As well as disseminating public health information to the general public and allows experts to perform predictions and modelling based on current trends. This information can help policy makers make the best decisions possible given current conditions. "It can help researchers and policy makers to identify trends that could be overlooked if the data were reviewed in tabular form". \cite{tebe2020covid19}

\vspace{5mm}







With this background, the project seemed timely, relevant and interesting.
It offered the potential to be data rich and ideally suited to a team project. The team felt it was important that the project encouraged the use of existing skills as well as allow for the natural development of new and relevant techniques and processes while also being worthy of the scope of the project.

\vspace{5mm} %5mm vertical space

Data visualisation and analysis techniques have been central in the efforts to communicate the statistics as well as the science around the COVID-19 virus. 
“Data visualization discussions can surface key issues, jump start conversations, and set the stage for further inquiry” \cite{fontichiaro2021using}. Many websites have Incorporated interactive dashboards as well as charts and graphs to to visualize complex and overwhelming pandemic data sets. 
“Visualization plays an important role in epidemic time series analysis and forecasting.”\cite{thorve2018epiviewer}

\vspace{5mm} %5mm vertical space

The team felt it would be beneficial as well as informative to create a web application that would take large COVID-19 data sets as well as other disease data and create a series of data visualisations from it. To compare past and present viruses and distinguish similarities along with differences. This would provide a clear view of COVID-19 and how similar viruses have spread.

\vspace{3mm} %5mm vertical space
Once the project area had been decided on, each team member focused on a pandemic or epidemic, investigated where to source relevant information for the pandemic or epidemic, and investigated different technologies for displaying data in a visual manner.

\vspace{5mm}

\textbf{Data Visualisation Research}
\begin{itemize}
    \item John Hopkins Dashboard
            An interactive web-based dashboard to track COVID-19 in real time.
    \item Gap Minder
            A website that provided a new way of looking at data on a variety of subjects.
    \item Epi Viewer
            A research project, based on a web application that provides a framework for exploring, comparing, and organizing temporal data sets.
    
\end{itemize}

During the initial research stage, the team were aware of the Spanish Flu as being the most recent pandemic. We thought that it would be interesting to include data for the Spanish flu and other epidemics like smallpox, SARs and MERs. Covid-19 data is very easy to source and the main problem was narrowing down which sources to use. Conversely data for the other diseases mentioned above was not so easy to source. The main reason for this is the age of the data, the Spanish Flu pandemic took place over one hundred years ago. Smallpox was finally eradicated in 1980. 
"Smallpox eradication was one of the greatest scientific and humanitarian achievements of the 20th century."\cite{Smallpox} The inclusion of the older disease data provides an interesting counterpoint to the current data rich modelled pandemic.

\vspace{2mm}

Data visualisations can give a seemingly very precise picture but it is always reliant on the veracity of the data and may run the risk of all data being equal. "An exponential growth model is usually assumed to characterise the early phase of epidemics. But, this assumption can lead to failure to appropriately capture the profile of the epidemic growth, eventually giving rise to non realistic epidemic forecasts"\cite{tovissode2020use}.



\section{Project Objectives}
The objective of the project is to create a web application that would process different virus data and create various data visualisations to ensure a simple way for users to view large complex pandemic data. 
To ensure the objectives were reached, the team outlined the following:

\begin{itemize}
  \item Investigate the field of interest and scope for the project.
  What is currently being done in the field, to understand some its challenges and potential development.
  
  \item Research and evaluate appropriate frameworks and tools available for development.
  Shortlist technologies which have the potential to be fit for purpose.
  
  \item Incorporate state of the art technologies, frameworks, databases and tools that will allow users to view, add, update, post and retrieve data.
  Evaluate which might be most suitable in practical terms for the scope of this project.
  \item The web application will, allow users to sign-up, login, view data visualizations as well as incorporate user interaction features, create unique user visuals and post user data to databases.
\end{itemize}

\section{Metrics for Success and Failure}
The outlining criteria for success and failure was essential in ensuring the applied project remained on track.  Each project outlined objectives listed in \emph{Section 1.3} will be reviewed at the end of the project and evaluated in the conclusion section. The initial success and failure objectives defined are outlined in \emph{Section 1.4.1} and \emph{Section 1.4.2}

\vspace{5mm} %5mm vertical space

\subsection{Applied Project Dissertation}
A selection of metrics were outlined specifically for the dissertation, they are as follows.

\begin{itemize}

    \item \emph{The final dissertation should be easily understood, allowing readers without knowledge or familiarity of the subject area to form a suitable understanding of the concept and areas discussed.} We measured this metric by asking for input from family members. Their feedback was very useful as they are not software students and did not have as much exposure to data visualisation applications.

    \item \emph{The  dissertation should be in order of 10,000 - 15,000 words, excluding appendices as well as approximately 35 pages (excluding diagrams, abstract, TOCs, references, appendices etc.)}

\end{itemize}

\subsection{Applied Project}
A selection of metrics were outlined specifically for the development of the applied project, they were as follows.

\begin{itemize}

    \item \emph{The applied project must be easy to use, navigate and attempt to deal with a task of problem deemed to be of sufficient technical challenge and depth.} At frequent stages of development feedback from team members and Dr. John French was evaluated and taken on board relating to the application. Still relying on family members to check ease of use and navigation particularly in the early stages of development when the application was not deployed.

    \item \emph{Collaboration between team members and supervisors should be consistent to ensure a smooth work flow throughout the project planning and development.)} In order for this metric to be adhered to, the team maintained continuous communication, keeping in touch using Microsoft Teams to manage meetings. Maintaining a tasks list in GitHub, daily communications through Whats App to discuss project ideas or issues.
    The team had weekly meetings with Dr John French throughout the development and planning of the applied project.

\end{itemize}

\section{Dissertation Summary}
This section contains a brief overview of the dissertation structure and provides a short description of each chapter.

\subsection{Methodology}
This chapter will discuss the investigation process, comparing software development methods used during the research phase, their results and the effect they had on the direction of the project. The decision making process and factors leading up to the decisions and design implementations will also be discussed. 

\subsection{Technology Review}
The technological review will outline the technical aspects of the project. This includes the different technologies, why they were chosen, how they were incorporated and their implementation. The benefits of the selected technologies will be evaluated and compared with similar alternatives.

\subsection{System Design}
A detailed explanation of the overall system architecture will be provided. We created an illustration of how the system architecture works, to explain in a visual way of how each technology interacts in the the architecture.

\subsection{System Evaluation}
An evaluation of the final applied project against the initial project objectives. The final result of the project will be evaluated including an analysis of areas of software quality, improvements or changes to the overall project.

\subsection{Conclusion}
To conclude, a summary of the context and objectives to remind the reader about the overall rationale and goals of the project. Key insights will be identified and reflected on. A final analysis will describe the teams overall experience and what the team learned while working on a project similar to one encountered in the software industry.

\chapter{Methodology}
\section{Project Management and Research}
This chapter will explore the pre-development process, the approach the team took with development and testing, how the team dealt with various problems faced, and the influence of regular supervisor meetings along with a conclusion based on what impact pre-development research had on the overall project direction.

\vspace{5mm} %5mm vertical space

The first team project meeting took place in the final week of September 2020. This meeting consisted of analysing the applied project requirements that had been defined and outlined. The team agreed to choose a topic that would be informative yet beneficial to the end user. It was concluded that the idea and architecture of the solution should be finalised as soon as possible to allow for necessary research and planned development.


\subsection{Brainstorming and Initial Supervisor Meeting}
Before development began and after the initial project topic was chosen each team member researched various technologies and concepts that could be potentially incorporated into the project. Soon after a brainstorming meeting was conducted to critically analyse each technology researched and the team decided whether each would be of good fit.

\vspace{5mm} %5mm vertical space

The team met prior to the initial supervisor meeting to produce effective ideas and questions to be asked relating to the overall architecture of the solution and the ultimate goals and objectives, these included:
\vspace{5mm} %5mm vertical space

\begin{itemize}


    \item \textbf{What technologies would be of best fit for the project?} \\
The team investigated many possible technologies for the project. Chapter three will fully outline our choices and reasoning for selecting these technologies.

    \item \textbf{What benefits would certain methodologies possess compared to others?}\\
The advantages and disadvantages of the methodologies, such as Agile and Waterfall, were considered by the team and are outlined in full in this chapter.
\end{itemize}

The first meeting with our supervisor Dr. John French took place in the first week of October. We outlined our basic project idea, potential research, development technologies, development methodology and collaboration approaches. Dr French advised the team  to spend the next few weeks to investigate and research the overall picture of how the applied project will be designed and implemented.


\vspace{5mm} %5mm vertical space

After the supervisor meeting the team decided to take this advice on board. Each member focused on researching the What? Why? How? of the project technology, idea and the overall end user experience as well as the relevance of the project. Once research was carried out the team had a meeting to discuss and  analyse the findings. Some questions asked were as follows:

\begin{itemize}

    \item {What development methodology and collaboration technique would be best to adopt?}

    \item{Would the chosen project idea be of relevance to the end user?}

     \item{Would the chosen technologies be of a professional standard?}

    \item{How would the chosen technologies fit together as a whole?}

    \item{Is the scope an appropriate size for a three person project?}

\end{itemize}

These questions will be fully discussed further in the dissertation.

\section{Methodology Consideration}
There were numerous possible methodologies to consider. After discussions with team members, the team decided it would be worthwhile to analyse and compare \textbf{Waterfall} and \textbf{Agile} to determine which methodology would be best suited to the applied project. These methodologies are amongst the most popular used by software development teams worldwide.
\vspace{5mm} %5mm vertical space


\subsection{Determining Development Methodology}
Following the decision of Agile and Waterfall as possible appropriate approaches to software development, the team began to research the advantages and disadvantages of both, along with deciding which methodology would be best to use when considering the scope, project goals and time frame. A critical analysis and overview of both methodologies were made and a conclusion based on the practical analysis of each in relation to the project was undertaken.

\section{Waterfall}
The Waterfall model is composed of a series of steps, illustrated in \emph{Figure 2.1}. These steps are used to break down a project into linear sequential phases to ease the development process.  \cite{petersen2009waterfall}. Waterfall allows progress to be easily measured, the complete scope of the project is known in advance, which can be preferred based on the type of project and software team. The Waterfall model tends to be among the less flexible approaches, the output of each stage completed is the input for the next and the overall progress follows a fixed downwards path like a waterfall.
\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.46]{img/Waterfall.png}
    \caption{Waterfall Methodology}
    \label{fig:my_label1}
\end{figure}
The waterfall model is still a widely used method for working on software projects today. It is arguably the most well known development model, which is likely attributed to how long the model has been around, not to mention the overall simplicity of the model. Each phase is of a waterfall project is completed sequentially and testing is done after tasks are completed. \cite{balaji2012waterfall}

\section{Agile}
Agile methodologies are a group of software development methods that are based on interactive and incremental development \cite{kumar2012impact}. The term agile stands for 'moving quickly'. It is characterised by an approach that allows rapid and continuous delivery of small and useful software. It takes the view  that production teams should start with simple and predictable approximations to the final requirement and then continue to increment the detail of these requirements throughout the life of the project. Agile methodology has an adaptive team which is able to respond to changing requirements as well as the ability to solve problems even late in the development cycle. \cite{balaji2012waterfall}.

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.8]{img/Agile.png}
    \caption{Agile Methodology}
    \label{fig:my_label1}
\end{figure}

The popularity of Agile development methodologies amongst the software industry has increased drastically, with almost 85.4\% of international surveyed software developers using Agile methodologies in their work. Research has also shown that Agile projects are 28\% more successful than traditional projects. The most important principle of the Agile methodology is customer satisfaction by giving rapid and continuous delivery of small and useful software.\cite{PopularityofAgile}



\section{Comparison between Agile and Waterfall}
During team meetings, research and analysis, both Agile and Waterfall were  analysed under the following headings:

\begin{itemize}

    \item \textbf{Requirement delivery}

    \item \textbf{Flexibility}

    \item \textbf{Compatibility}

     \item \textbf{Methodology past experience}

\end{itemize}

By taking the above headings into an account comparisons were drawn for both methodologies.

\vspace{2mm}

\begin{table}[ht]
  \centering
  \begin{tabular}{x{5cm}p{5cm}}
    \toprule \\
    Agile & Waterfall \\
    \midrule \\
    + Ability to respond to the changing requirements of the project. & - Requirements are clear before development starts. \\
    + Errors can be detected and solved quickly. Which is a big advantage. & + Each development phase is completed in a set time frame. Then it moves to another phase. \\
    + There is constant communication and inputs from the team and supervisor & + It is a linear model so therefore easy to implement. \\
    - Project can easily fall off track. & - Requirements, Specification and Design can take up a lot of time. \\
    + The end point of the project is not clearly defined. Requires continuous development and changes to design. & - Low flexibility meaning it may be difficult of even impossible to make major changes while in the implementation phase \\
    
    \bottomrule
  \end{tabular}
  \caption{Agile V's Waterfall comparison.}
  \label{table:mytable}
\end{table}


Following various comparisons between Agile and Waterfall, it became clear to the team that an Agile approach would best suit the development of the outlined applied project. This approach would aid the development process in numerous ways, these include:

\vspace{5mm}
1. \textbf{Errors can be detected and solved quickly} - The team thought it would be beneficial to be able to detect and solve problems quickly, especially when the team did not have much experience with using GitHub collaboratively together as a team.

2. \textbf{The ability to develop small but functional software via releases} - Based on feedback from our supervisor the priorities of the project could be subject to change. Small incremental changes means there would be flexibility and versatility throughout the development stage.

3. \textbf{User Stories}
A user story is a tool used in Agile software development to simply describe a software feature from an end user point of view. A user story describes the type of user, what they want and why they need this feature. It helps to create a simplified description of a requirement and focus the development team on the feature itself. We created user stories in the first few weeks of planning.

4. \textbf{Scrum Methodologies and GitHub project boards } - The idea of incremental releases in parallel with scrum sprints based on user stories using GitHub project boards to manage the workflow was something the team thought would be of major benefit to the overall project.

5. \textbf{Frequent supervisor and team meetings} - Information sharing in teams is an important aspect of successful software development. The team felt it would be crucial to hold regular team meetings to discuss what each member is working on as well as attend all weekly supervisor meetings. The team and supervisor meetings focused on what we worked on last week, what we will work on in the coming week and any issues encountered.

\subsection{Agile Methodology}
Deciding what agile methodologies was the next big step the team had to decide on. After research the team came to the conclusion that Scrum and GitHub project tasks would most beneficial for the team to use in the development of the project.


\subsection{GitHub Tasks}
Since the beginning of development for the applied project the team set up and adhered to GitHub tasks by assigning relevant work to do each week. GitHub tasks also knows as GitHub Kanban is a project management tool designed for developers to coordinate, track and update their work in one place, so projects stay transparent and on schedule.

\vspace{5mm} %5mm vertical space


It provides tools to allow developers to prioritize and visualize the main elements of the project in progress and also created a clear picture of what project tasks need to be started, completed and which tasks are currently in progress.\cite{GitHubtasks}

\vspace{5mm} %5mm vertical space

The ability to track project progression on the same platform where the project is being collaborated on is beneficial as well as easier to use than using an external project management tracker like Microsoft Project.

\vspace{5mm} %5mm vertical space


\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.50]{img/GitHubToDo.PNG}
    \caption{GitHub Tasks}
    \label{fig:my_label1}
\end{figure}


Figure 2.3 shows the GitHub task sheet used during development of the applied project. It consists of five main columns:

\begin{itemize}
\item \textbf{To Do}\\
This section was for tasks that were identified but not actioned yet.
\item \textbf{In Progress}\\
This section was for tasks that were in progress and not complete.
\item \textbf{Done Backend}\\
The amount of completed tasks was quite large it was decided to split the completed tasks into front and backend tasks. This section displays all the completed backend tasks.
\item \textbf{Done Frontend}\\
Completed tasks relating to the front end development were moved from in progress to here.
\item \textbf{Done Testing}\\
Completed test tasks are moved here.
\end{itemize}

\vspace{50mm} %5mm vertical space

\subsection{Scrum}
As well as using GitHub Tasks to manage project management, the Scrum methodology was incorporated and employed. This development methodology assumes that the project or systems progress is an unpredictable process that can be described as an overall progression \cite{schwaber1997scrum}. The Scrum methodology is designed for teams to break down work into goals that can be completed in a specific time frame called sprints. Short sprints are generally one to two weeks in length. We decided to make our sprints weekly as we were meeting our supervisor weekly. We met up as a team at least once a week but often more to discuss the project progress.
At the end of each week, a supervisor meeting would be held where the team would discuss their progress with the supervisor.

\vspace{5mm} %5mm vertical space

At the end of each supervisor meeting, the goals for the next Scrum Sprint were defined and discussed in detail. Any new goal was also assigned and recorded in the teams GitHub Tasks board. These tasks were undertaken in a high to low priority order.

\vspace{5mm}
When the team encountered problems, we tried where possible to resolve them together as a team. We discussed the problems encountered and each team member tried to help with finding a possible cause to the problem and trouble shooting where possible. We researched each other's problems on line and sent relevant research and information to each other.

\vspace{5mm} %5mm vertical space


\chapter{Technology Review}
This chapter will outline the technology used and the reasoning for choosing a particular technology. Below is a list of technologies used, descriptions of the technologies at a conceptual level are included for each technology.
\begin{itemize}
\item Git
\item GitHub
\item React
\item Flask
\item MongoDB
\item FireBase
\item FireStore
\item D3
\item JavaScript
\item Python
\item Visual Studio Code
\item Live API Calls

\end{itemize}

\section{Version Control}
Version control is an essential element of any collaborative undertaking. An organisation in GitHub was set up to manage the version control for the project. At the beginning of the project the team had limited experience with collaborative version control as the project progressed we became more experienced. As a result in the early stages the team were investigating different aspects of data visualisation, this resulted in  smaller repositories to track our work.  When this investigation concluded we created a new repository where all the future work of the project would be tracked. 
\subsection{Git}
Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. It is a free and open source software distributed under the terms of the GNU General Public License version 2.
Git allows and encourages the user to have multiple local branches that can be entirely independent of each other. The creation, merging, and deletion of those lines of development takes seconds.\cite{git}
Git is installed and maintained on the users local system and provides a record of ongoing programming versions. It allows developers to rollback to an older version of the code if required.
There are other popular version control systems for example Apache SVN or CVS, the team chose Git as it was a technology that we were familiar with but did not have a lot of experience with. We felt that there would be many large learning curves ahead of us and if we could mitigate the size of the learning curve by choosing a familiar technology it would help us focus on other areas that required more learning. Having said that there was a significant learning curve using Git with a team. Git gave us experience of using branches, merging branches and manually resolving conflicts. See Figure 3.1 for an example of git on a local machine.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{img/git.PNG}
    \caption{Git on local machine}
    \label{fig:my_label01}
\end{figure}



\subsection{GitHub}
GitHub is a web-based code hosting platform for version control and collaboration. It lets users work together on projects from anywhere.\cite{github}
GitHub provides students of GMIT with free accounts, for this project a free account was sufficient as there is a facility to make the project public or private. Using GitHub allowed the team to work entirely remotely and resolve any issues with the project. 
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.3]{img/github.PNG}
    \caption{Github Organistaion}
    \label{fig:my_label02}
\end{figure}





\subsection{Flask}
Flask is a micro web framework written in Python. It is classified as a microframework because it does not require particular tools or libraries. The “micro” in microframework means Flask aims to keep the core simple but extensible. It has no database abstraction layer, form validation, or any other components where pre-existing third-party libraries provide common functions. However, Flask supports extensions that can add application features as if they were implemented in Flask itself. Extensions exist for object-relational mappers, form validation, upload handling, various open authentication technologies and several common framework related tools.\cite{flask}
The architecture of our project required a back end,front end and a database. We had some experience with MEAN(MongoDB, Express, Angular, NodeJs)  and MERN(DB, Express, React, NodeJs) stacks from previous college projects. More recently we had some exposure to Flask as a backend in Emerging Technology project. We had decided to use React for our frontend, which we had used for a previous MERN project. We had also used Angular previously for a MEAN project but decided to use React. There will be further discussion in the React section about why React was chosen. Part of the teams learning objectives was to use new technologies, to the team, and learn as much as possible about them. For this reason we chose Flask as our backend, as it offered flexible options re database and front end choices. From implementing Flask and reading documentation, the idea of virtual environments was introduced. Virtual environments are independent groups of Python libraries, one for each project. Packages installed for one project will not affect other projects or the operating system’s packages.\cite{virtualenv}
Most importantly using Flask allowed us to write our own API calls to our MongoDB Atlas database.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.45]{img/flask.PNG}
    \caption{Flask}
    \label{fig:my_label03}
\end{figure}


\subsection{React}
React is a JavaScript library, used for building reusable components. React allows users to design simple views for each state in their application, and React will efficiently update and render just the right components when the data changes.
Declarative views make the code more predictable and easier to debug. Build encapsulated components that manage their own state, then compose them to make complex User Interfaces. React does not make assumptions about the users technology stack, allowing the development of new features in React without rewriting existing code.\cite{react}
React recommends using JSX, an syntax extension of Javascript. We have used JSX and JavaScript in our project.
See example code from the project.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.4]{img/jsx.PNG}
    \caption{Example of JSX}
    \label{fig:my_label4}
\end{figure}


\vspace{5mm}
When researching what front end software to use we considered Angular and React. From our research we compared the two technologies. Included below is a table outlining the advantages and disadvantages of both.
\begin{table}[ht]
\centering
\begin{tabular}{ |p{3cm}||p{3cm}|p{3cm}|p{3cm}| }
 \hline
 \multicolumn{4}{|c|}{FrontEnd Technology Comparison Angular v's React} \\

 \hline
 Heading& React& Angular&Best Option\\
 \hline
 Structure   & JS Library    &Full framework &  React\\
 Application & Suits SPA    & Suits large App   &React\\
 Updates &Often & Twice a year&  React\\
 Components and Size    &Uses virtual DOM & Uses Real DOM&  React\\
 Industry Demand&   897  & 366& React\\
 Professional Popularity& 68.9\% &54\%   &React\\
 Dubug& Easy& Not so Easy& React\\

 \hline
\end{tabular}
 \caption{React V's Angular comparison.}
  \label{table:myTable}
\end{table}

\hfill \break


Information about Job popularity taken from a google search on the 15th of April 2021
Information about professional popularity taken from StackOverflow survey(2020) of most loved Web framework.\cite{favtech}

\vspace{5mm}
There is no definitive way to decide in advance, which technology would be the best to use, but comparing relevant aspects between technologies can help narrow the choices and help with making the final decision.\\Having considered all of the information from the table above and taking into account our previous experiences with both Angular and React we chose React as our front end development technology.
Choice of FrontEnd Technology - can be looked at from 2 perspectives 1. Learning outcomes.
2. Good fit for the task we were trying to achieve within the project.

Having completed the project, we feel it had been a good choice from both of those perspectives.

\subsection{MongoDB Atlas}
MongoDB Atlas is a database as a service, a cloud based service.
When designing the application we were unsure what format our data would take, if the data was purely relational it would only need a SQL type database, if the data was non relational it would need a noSQL database.
NoSQL databases (aka "not only SQL") are non tabular, and store data differently than relational tables. NoSQL databases come in a variety of types based on their data model. The main types are document, key-value, wide-column, and graph. They provide flexible schemas and scale easily with large amounts of data and high user loads.  NoSQL databases can store relationship data—they just store it differently than relational databases do. When compared with SQL databases, many find modeling relationship data in NoSQL databases to be easier than in SQL databases, because related data doesn’t have to be split between tables. he simplest type to describe is the document database, in which it would be natural to combine both the basic information and the customer information in one JSON document. In this case, each of the SQL column attributes would be fields and the details of a customer’s record would be the data values associated with each field.\cite{mongodb}\\
\vspace{2mm}
\textbf{For example: Last\_name: "Jones", First\_name: "Mary", Middle\_initial: "S", etc .}
\vspace{2mm}

For our data storage we decided to use a noSQL Database as this stored data in the way we required. We could have created a cloud based sql database using something like Postgres, but the amount of data we were handling did not require separation.
In the end most of our data was relational data but we felt that MongoDB Atlas was still a good fit as it allowed us to add other noSQL type data if the need arose. Each document has a different number of fields, size, content, and is stored in a JSON like format called BSON. The documents in MongoDB do not need to have a schema defined beforehand. The fields can be created on the fly. The data model available within the MongoDB allows developers to represent the hierarchical relationships, store arrays, and other more complex structures easily.
The mongo shell is an interactive JavaScript interface to MongoDB. You can use the mongo shell to query and update data as well as perform administrative operations.\cite{mongodb}
We used the Mongo shell to upload files to the database from a local system. This tool was used to upload large csv files  with over 4000 lines to a collection in our database.
We used MongoDB Atlas Database, a product from MongoDB which offers MongoDB as a clound based database(DBaaS). We accessed data stored on MongoDB, via api calls from our flask api. From this data graphs can be generated. We also stored data inputted by the application users, for example ratings on the home page or a symptoms tracker. This data could be retrieved from MongoDB and displayed on the application.
this data was posted to the database using an api call. This data could also be retrieved.\\
\vspace{2mm}

An aspect of using MongoDB Atlas is how the database is structured in terms of being a distributed system. It also offered peace of mind about the integrity of our data and we knew that the data would not be lost, or that the service would always be continuous, which is a fantastic option for a free version of the product.
This helped solidify  some of the central properties of distributed systems which we learned about in the Distributed Systems Module.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.35]{img/clusterDB.PNG}
    \caption{MongoDB Atlas Cluster}
    \label{fig:my_label04}
\end{figure}


\section{Languages Used}
\subsection{JavaScript}
JavaScript is high-level, often just-in-time compiled, and multi-paradigm. It has curly-bracket syntax, dynamic typing, prototype-based object-orientation, and first-class functions.
Alongside HTML and CSS, JavaScript is one of the core technologies of the World Wide Web. Over 97\% of websites use it client-side for web page behavior, often incorporating third-party libraries. All major web browsers have a dedicated JavaScript engine to execute the code on the user's device.
As a multi-paradigm language, JavaScript supports event-driven, functional, and imperative programming styles. It has application programming interfaces (APIs) for working with text, dates, regular expressions, standard data structures, and the Document Object Model (DOM).
The ECMAScript standard does not include any input/output (I/O), such as networking, storage, or graphics facilities. In practice, the web browser or other runtime system provides JavaScript APIs for I/O.
JavaScript engines were originally used only in web browsers, but they are now core components of other software systems, most notably servers and a variety of applications.\cite{javascript}
Parts of the project were written in JavaScript, these include Live Covid-19 data visualisation, home page, SARs and MERs. 
\subsection{JSX}
JSX is an extension of Javascript and stands for JavaScript XML.
JSX allows us to write HTML elements in JavaScript and place them in the DOM without any createElement()  and/or appendChild() methods. JSX converts HTML tags into react elements.\cite{jsx}
React encourages the use of JSX for development, though a developer could use JavaScript if preferred. JSX was used in the stats page for the creation of the country drop down, overlay graph and interactive bar chart feature. 
\subsection{Python}
Python is an interpreted, high-level and general-purpose programming language. Python's design philosophy emphasizes code readability with its notable use of significant indentation. Its language constructs and object-oriented approach aim to help programmers write clear, logical code for small and large-scale projects.
Python is dynamically-typed and garbage-collected. It supports multiple programming paradigms, including structured (particularly, procedural), object-oriented and functional programming.\cite{python}
Flask is written in python, the api backend of the project is written on python code. All api routes use Flask Blueprint().
Flask Blueprints encapsulate functionality, such as views, templates, and other resources.

\section{Development Environment}
\subsection{Visual Studio Code}
Visual Studio Code is a lightweight but powerful source code editor which runs on your desktop and is available for Windows, macOS and Linux. It comes with built-in support for JavaScript, TypeScript and Node.js and has a rich ecosystem of extensions for other languages (such as C++, C\#, Java, Python, PHP, Go) and runtimes (such as .NET and Unity).\cite{vscode}
According to Visual Studio Code,"Visual Studio Code combines the simplicity of a source code editor with powerful developer tooling, like IntelliSense code completion and debugging.
First and foremost, it is an editor that gets out of your way. The delightfully frictionless edit-build-debug cycle means less time fiddling with your environment, and more time executing on your ideas."\cite{whyvscode}

\vspace{5mm}
The team agrees, VS code is extremely easy to use, is much faster than other IDE's, the inbuilt support for JS and Node.js is something we considered, it also allowed us to develop the backend which was written in python, without having to use another IDE. It allowed seamless integration between the different coding languages.


\section{FireBase}
Firebase is a Backend-as-a-Service that was founded in 2011 that provided developers an API that enables integration of online chat functionality into their websites. 

In 2014, Google acquired Firebase and has since built it into a full fledged mobile and web development platform with over 19 different products and services with more than 1.5 million developers worldwide.

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.8]{img/firebase2.PNG}
    \caption{hosted in the cloud}
    \label{fig:my_label}
\end{figure}



Firebase uses what is known as a NoSQL database for storing data in a Realtime Database. As the name suggest this means that data is not stored in the tables and rows found in relational database management systems (RDBMS) such as Oracle Database or Microsoft SQL Server. Nor is the data accessed using Structured Query Language (SQL) statements. Instead, the data is stored in the form of a JSON object. 

JSON is an acronym for JavaScript Object Notation and it defines a syntax used to transmit data in a format that is both lightweight and easy for both humans and software to read, write and understand.

JSON objects typically consist of a key/value pair, where the key uniquely identifies the object within the database and the value represents the data that is being stored. Multiple JSON objects are structured in the form of a JSON tree.

The Firebase SDK supports programming in C++, Java, JavaScript, JavaScript/Node.js, Objective-C, and Swift. Angular, Backbone, Ember and React are supported through bindings to the database.\cite{firebase}


\subsection{User Authentication}
Firebase Authentication provides backend services, easy-to-use SDKs, and ready-made User Interface libraries as shown in Figure 3.7 to authenticate users to our app.
\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.5]{img/auth.PNG}
    \caption{User data to the Database}
    \label{fig:my_labe2}
\end{figure}



It supports authentication using email and password accounts, phone auth, Google, Facebook, Twitter, and GitHub login, and more. The Firebase Authentication (SDK) can be used to manually integrate one or more sign-in methods into an app.\cite{fbauth}

\vspace{5mm}

To sign a user into our app, we first get authentication credentials from the user. 
These credentials can be the user's email address and password, or an OAuth token from a federated identity provider. Then, we pass these credentials to the Firebase Authentication SDK. See Figure 3.8 for login and identity code.

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.55]{img/login.PNG}
    \caption{user login and identity}
    \label{fig:my_labe3}
\end{figure}

Our backend services will then verify those credentials and return a response to the client.
After a successful sign in, it will allow the navigation of sensitive routes.
Authenticated user will access routes that previously locked.


\subsection{Realtime database}

The Firebase Realtime Database is a cloud-hosted NoSQL database.
Data is synced across all clients in real-time and remains available even when an app goes offline.
Whenever you update data in the real-time database, it stores the data in the cloud and simultaneously notifies all interested devices in milliseconds. The real-time database is also optimized for offline use.
Whenever a user loses thier connection, the database STK uses a local cache on the device to serve and store changes. This means that when the user comes back online, their local data is automatically synchronized. To keep our data secure, we used database security rules.
The security rules are securely stored with the real-time database on our server.\cite{fbdb}

\vspace{13mm}

We wanted to use Mers and Sars data to display D3 graphs for our group project.
We could not find an API that provided the data we required, but we were able to find all the data we needed in CSV format from various sources. 
We parsed all that CSV data into JSON and used Firebases’ Command-line interface to upload all the data into the server, as shown in Figure 3.9.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.35]{img/Firebasedb.PNG}
    \caption{Storing and managing our data}
    \label{fig:my_labe4}
\end{figure}

\section{Cloud Firestore}
Cloud Firestore is Firebase's fully managed cloud-native NoSQL document database that is fast and serverless. It's a new and improved version of the Real-Time Database, and its capabilities include real-time updates, offline synchronization, scalability, and multi-region deployment. Unlike a SQL database, there are no tables or rows. Instead, you store data in documents, which are organized into collections. Each document contains a set of key-value pairs.
Cloud Firestore is optimized for storing large collections of small documents.
All documents must be stored in collections. Documents can contain subcollections and nested objects, both of which can include primitive fields like strings or complex objects like lists.\cite{firestore}


\vspace{6mm}

We used Cloud Firestore for our Message Board.
User identity is an important security concept. Different users have different data, and sometimes they have different capabilities.

For example each message is associated with the user that created it. Users may also be able to delete their own messages, but not messages posted by other users.



The SDK handles all the state management and data syncing in between the client and server. A collection of messages was set up and for each of these messages a sub collection of messages was created.

\vspace{5mm}

If we look at the actual database we can see that each message has an owner and then each individual message is an object.
See Figure 3.10 for an example of storing and managing messages.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{img/FirestoreMessage.PNG}
    \caption{Storing and managing messages}
    \label{fig:my_labe6}
\end{figure}


The database contains the user ID, a created timestamp and the message content.
When a user is logged in and they created a new message it will create this document with their user ID as the owner ID. See Figure 3.11 as an example of the code.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.95]{img/message.PNG}
    \caption{How to add message to the message collection}
    \label{fig:my_labe5}
\end{figure}

\vspace{5mm}

\section{D3}

D3.js (Data-Driven-Documents) is an open-source JavaScript library that lets you create dynamic data visualizations in web browsers using SVC, HTML 5, and CSS.
Most data visualization tools require Python, D3.js visualizations are created entirely using JavaScript.

\vspace{5mm}

While most charting libraries (such as Chart.js and Highcharts) provide ready made charts D3 consists of a large set of building blocks from which custom charts or maps can be constructed.

\vspace{2mm}
D3’s approach is much lower level than other charting libraries. Creating a bar chart with Chart.js is just a few lines of code.\cite{d3}

Creating the same chart with D3 you need to:

\begin{itemize}

\item \textbf{create SVG rect elements and join them to the data}
\item \textbf{position the rect elements}
\item \textbf{size the rect elements according to the data}
\item \textbf{add axes}

\end{itemize}


In order to \textbf{use DOM in React directly}, we needed to use refs. See Figure 3.12 for an example of refs.\\

\vspace{10mm}



It takes two simple steps:

\begin{itemize}

\item \textbf{creating a ref in constructor()}
\item \textbf{connecting [div] to the ref}

\end{itemize}

See Figure 3.12 for ChartWrapper.js code.


\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{img/D3Ref.PNG}
    \caption{How to access D3}
    \label{fig:my_label4}
\end{figure}

\chapter{System Design}
\begin{center}
      \includegraphics[scale=0.5]{img/basic architecture.png}
\end{center}



\section{Architecture Overview}
The architecture of the project is a three tiered architecture, consisting of a front-end, a back-end and a data tier.
Three-tier architecture is a well-established software application architecture that organizes applications into three logical and physical computing tiers: the presentation tier, or user interface; the application tier, where data is processed; and the data tier, where the data associated with the application is stored and managed.
The chief benefit of three-tier architecture is that because each tier runs on its own infrastructure, each tier can be developed simultaneously by a separate development team, and can be updated or scaled as needed without impacting the other tiers.\cite{architecture}
Our architecture also includes a login facility using Firestore and some of the static data for the components rendering D3 data is stored in Firebase.
The project also uses Firebase to access static data for D3 visualisation and manages user login authentication. Firestore is used to manage a message board which is only accessible for an authenticated user.


The front end was worked on initially, once the front-end was functioning a decision was made about the architecture of the project. Flask was decided on as the back-end, which would interact with the database tier and the front-end.
Once the architecture was finalised, we wrote our own api calls to the database.
 
We had decided on Flask because React does not tie a developer to use a particular back-end, and we wanted to learn more about Flask and python, which we had some familiarity with.

\section{Live API Calls}
Data visualization gives us a clear idea of what the information means by giving it visual context through graphs. This makes the data more natural for the human mind to comprehend and therefore makes it easier to identify trends and patterns within large data sets. Having attractive and clear visualizations are important but it is just important to work with reliable and correct data so as not to mislead users.

The most important aspect of developing a data visualization application is the data itself. It is essential for data visualization applications to fetch data from a source that is up to date and reliable. When developing the live API component and after much research the team felt it would be best to use Disease.sh API and MathDroid API to gather live Covid-19 data from around the world.

Disease.sh is a popular open source API for disease related statistics that has handled over 45 billion API requests to date. Both site source their data from John Hopkins University, the New York Times, Worldometers and Apple reports to give comprehensive, informative and most importantly reliable data. Responses from these APIs are served in JSON format which allows for easy and reliable integration.\cite{disease}\\ See Figure 4.1 for a code example of how data was fetched from Disease.sh API and assigned features to be used with the API data through the use of JavaScript.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{img/code.PNG}
    \caption{Live API Calls}
    \label{fig:my_label04}
\end{figure}





\section{Three tier architecture}
\subsection{Data Tier}
 The project relies on daily updated apis for Covid19 data. As part of the initial project we investigated other pandemics and epidemics. Fortunately these occurred years ago, unfortunately it meant that the data was not easy to find. We found some limited data on SARs MERs and Smallpox. We chose a cloud based database MongoDB Atlas to manage some of the data required for the project. The smallpox data was stored in MongoDB and the SARs and MERs data was stored in Firebase.
Firebase was used for data that rendered D3 images. External api's were used for the Covid-19 data. The app allows a user to record temperature, symptoms and leave a rating or review, this information is stored in MongoDB and can be retrieved. Everytime the a temperature is entered a temperature graph dynamically changes.

\section{Logic Tier - Back end}
Using RESTful API's which follow an architecture that use predefined and stateless operations to access web resources.
The API is written with Flask, uses Pymongo, a python library specifically for interacting with a Mongo database.
Requests from the app are sent by a request from the code in the front end, using JavaScript or JSX to the RESTful API, this API sends a connection request to MongoDB Atlas which is on the web. Flask retrieves the information and sends it to the be displayed at the application end.

\section{Application Tier - Front end}
React was used to develop the client side of the application. React is an open source JavaScript library for rendering views. React apps are an example of single application applications(SPA), the application code, like HTML, CSS and Javascript is loaded once. The SPA only sends what the user needs, for example by clicking on a button only the information associated with that button is reloaded not the whole page. This piece by piece, client side method makes load time must faster for users and makes the amount of information a server has to send a lot less.
When a user interacts with the app JavaScript intercepts the browser events and depending on where the data is coming from different API calls are made, for example if the Data is from the MERs or SARs dataset an API call is made to Firebase. If data is required from the Smallpox data or a users inputted information an API call is made using Flask and connected to the relevant MongoDB Atlas collection.


\begin{itemize}
\item Flask
\item React.js
\item MongoDB Atlas
\item Firebase


These technologies were chosen as they give developers the ability to handle large volumes of data and, at the same time, render a nice modern interface on the client side.

\end{itemize}

\section{Heroku - Deployment}
\begin{center}
      \includegraphics{img/HerokuArchitecture.png}
\end{center}
Heroku is a platform as a service(PaaS) based on a managed container system, with integrated data services and a powerful ecosystem, for deploying and running modern apps.\cite{heroku}
We deployed the project to the web using Heroku. We investigated different options for deployment, there are many companies that offer a free option or trial PaaS product, companies like Plesk, Cloudify and Heroku, as well as Open Source PaaS tools.The project deployment was implemented towards the end of project development, because we had prior experience with Heroku and limited time we decided to try Heroku first. If we felt that Heroku was not suitable we would try another platform like Plesk or an open source option like Dokku, but Heroku worked well and with the time frame left we decided there was no need to investigate another option. Heroku's free option was sufficient for our app deployment.


\chapter{System Evaluation}

\section{Chapter Overview}
In the System Evaluation chapter we will touch on the overall design of the system.
We will evaluate whether or not the objectives were met in the completion of the web application.
The testing that went into the project will also be documented.
We will also be reviewing any limitations and areas of improvement within this project.

\section{Project Objectives}
Initially the goal of this project was to develop a data visualization website that analyses various viruses such as Covid-19, Sars, Mers and Smallpox using different technologies.

\section{Testing}
This section will discuss how the application was tested.
The entire system was fully tested to ensure that there were no faults in our web application.
We felt that it was essential to fully test our web application in the development as well as in the completion of the project.
Some of the testing that we conducted included Unit Testing and System Testing.


\subsection{Unit Testing}
Unit Testing is a type of software testing where individual units or components of a software are tested. 
The purpose is to validate that each unit of the software code performs as expected.

A unit may be an individual function, method, procedure, module, or object.\cite{unittest}
The reason that it is done this way is to verify that each unit of our application is working correctly.


\subsubsection{Jest}
Jest is a JavaScript unit testing framework, used by Facebook to test services and React applications.
Jest also provides Snapshot testing, the ability to create a rendered ‘snapshot’ of a component and compare it to a previously saved ‘snapshot’. The test will fail if the two do not match.\cite{jest}

\vspace{5mm}

Jest was used to test both Firebase and Firestore functions. We researched different options for testing Firebase and Firestore, from our research we concluded that Jest was a common framework used with good documentation available. See Figure 5.1 for testing with Jest.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{img/jest.PNG}
    \caption{Testing with Jest}
    \label{fig:my_label4}
\end{figure}

\subsubsection{Firebase Emulators}
The Firebase Local Emulator Suite consists of individual service emulators built to accurately mimic the behavior of Firebase services. This means we can connect our app directly to these emulators to perform integration testing or QA without touching production data.\cite{fbemulator}

The Firebase Emulators make it easier to fully validate the app's behavior and verify our Firebase Security Rules configurations.
We used the Firebase Emulators to run and automate unit tests in a local environment. 

\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.7]{img/FirebaseEmulator.PNG}
    \caption{Testing with Firebase Emulator}
    \label{fig:my_label4}
\end{figure}

\subsubsection{Postman}
Postman is an application for testing APIs, by sending request to the web server and getting the response back. It allows users to set up all the headers and cookies the API expects, and checks the response.\cite{Postman}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.4]{img/TestCode.PNG}
    \caption{Testing API}
    \label{fig:my_label10}
\end{figure}

Figures 5.4 and 5.5 show a GET and POST request using Flask.

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.3]{img/TestGet.PNG}
    \caption{API Get Request}
    \label{fig:my_label11}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.3]{img/Testpost.PNG}
    \caption{API Post Request}
    \label{fig:my_label12}
\end{figure}



\subsection{System Testing}

\subsubsection{Selenium}

Selenium is a portable framework for testing web applications.\cite{selenium}\\ This allows the user to create tests which will monitor the users actions performed and log them so that these tests can be run and re-run with the click of a button. Selenium was used to test the overall system functionality and validate the overall application. These tests were ran against Firefox to test essential functionality such as drop down lists in stats, Covid-19, Mers/Sars and for the page navigation links. 

Selenium allowed the testing of vital functionality via automated clicks. In Figure 5.6 the projects Heroku URL is specified for Selenium to run pre-written tests against. By defining specific actions on features by adding their Xpath, Selenium can automate an isolate tests against the specified path to determine if the feature is working smoothly and as expected.
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.4]{img/sel.PNG}
    \caption{API Post Request}
    \label{fig:my_label22}
\end{figure}



\section{Limitations and areas of Improvement in this project}

\subsection{Limitations}
At the time of submission there are a few limitations. Our application is at a prototype stage of development. Currently our application works fully locally. It is desirable for us to have the application up and running on the cloud.  The project is deployed on the cloud using Heroku as a Platform as a service. The deployment is not complete as we encountered issues with deploying flask, to Heroku. As a result the deployed project has some functionality missing, such as our rating and checking temperature functionalities, but most elements are working as expected. 




\subsection{Improvements}
Improvements that can be made to the current system could include adding more features. Initially, we had an idea of having an online symptom checker by using a chatbot powered by artificial intelligence. The user could diagnose symptoms for signs of Covid-19.
More interactive elements. For example the project could have Covid-19 news tracker or worldwide headlines for Covid-19. 

\subsection{System Evaluation Conclusion}
Overall we are happy with how the project turned out. We feel that we have covered all of the objectives stated in the introduction chapter. We investigated the field of data visualisation, we researched other like applications like epiviewer.\cite{thorve2018epiviewer}\\
We evaluated each potential framework against each other and from this evaluation chose what we felt was most appropriate for our development.
We researched modern technologies how applicable they would be in our software development careers. All application developments were met. We adhered to the outlined metrics for success and failure, the scope of the project was sufficient for a three person project and we learned new technologies while also improving our existing skills in familiar technologies.


\chapter{Conclusion}

\subsection{Context Objectives }
Selecting the topic of data visualisation was partly inspired by an interest in how data visualisation can impart a lot of information without the need for reading extensive data and inspired by the Covid-19 pandemic and lockdown.
The overall goal of the project was to investigate different methods of data visualisation, and to present our findings to an end user via a web based application.
We investigated the field of data visualisation and the scope for the project.
We evaluated and researched the appropriate frameworks and tools available for development.
We incorporated state of the art technologies, frameworks, databases and tools that allow users to view, add, update, delete, post and retrieve data.
The web application, allows users to sign-up, login, view data visualizations as well as incorporate user interaction features, create unique user visuals and post user data to databases.




\subsection{Methodology Objectives}
The team found working entirely remotely challenging, however we overcame that. Working remotely is it is own discipline and one that is definitely worth learning. Our choice of implementing the Agile methodology was ideally suited to remote collaborative teamwork. Weekly sprints and using user stories helped us stay focused on the task. The team had weekly meetings with just the team and separate weekly meetings with our supervisor. The fact that we had to work remotely made us more aware of the need to be in frequent communication with each other, if we were on campus there would be much more opportunistic meetings about the project, which would have made resolving complex issues easier. 

\subsection{System Evaluation Findings}
\begin{itemize}
\item \textbf{Importance of testing}\\
Towards the end of development the team became aware of the importance of testing. It is possible that we could have implemented testing earlier in the product development. Initially we used trial and error as our method of testing but realised that if we could have implemented Test Driven Development or Behaviour Driven Development it may have helped with the project. 
\item \textbf{Working with different technologies}\\
The team feels that we have benefited from working with the technologies we chose. Often we faced problems with certain aspects of different technologies but usually found a way of working through the problem. These problems helped hone our problem solving skills. By reading the relevant documentation to try and figure out how and why everything would work together. However, we realised how important research is when creating a software application.

\end{itemize}

 \subsection{Opportunities for future Investigation}
As the project is at a prototype stage there is plenty of scope to research further features.
\begin{itemize}
\item \textbf{Fetch Covid-19 headines from external news outlets}\\
The team felt it would have been useful to fetch live news headlines from external news websites, if we had more time this unique feature would allow users to access real time Covid-19 updates while still interacting with the application.
\item \textbf{More data on different epidemics}\\
It would be interesting to find other epidemic data sets, for example Ebola or Polio and generate interactive charts and graphs from these.
\item \textbf{Overlay data}\\
With more data sets it may be possible to track older epidemics and overlay generated graphs to see if there was any new information that could be learned from this comparison.
\item \textbf{More querying of the existing databases}\\
We could write more API calls to the database and generate many different types of charts, or map information to other types of graphs.
\end{itemize}



\subsection{Group Reflections}
The benefit of hindsight is a wonderful thing, if we had to do it again there are many things we would probably do differently.
We would try to manage our time more effectively. In hindsight we would make better plans for the project and would know which areas to prioritise and focus on more. We would be more decisive about what did and did not work and cut our losses earlier. Try to improve our research of topics that posed difficulties.
We most definitely would deploy the project at an earlier stage of development. This would allow us more time to resolve any deployment issues. The project is currently deployed on Heroku but we ran out of time to fix an issue we were having with Flask connection. Having completed the project we feel that if we were to do it again we would be in a very good position to know what worked, what did not work and how to tackle these problems earlier. We definitely would be able to manage our time better a second time around.\\
\vspace{5mm}

There are many achievements from working on a group project. The biggest achievements we gained from this module would be team working and problem-solving skills. As we had weekly meetings on Teams and discussed everything we needed to complete this project we feel that this has helped us improve in areas like communication and decision making.\\
\vspace{5mm}

We found the project itself difficult at times but we had an excellent working relationship. It is rewarding to think that we completed this project in an unusual environment, normally we would be on Campus and this would have given us more opportunities to meet up between labs and lectures, which we feel would have made the project a bit easier in terms of coordination and especially writing the dissertation.






\appendix 
\chapter{}
\section{GitHub Link}
\href{https://github.com/4th-year-project-2020-2021/Final-Year-Project-Data-Visualization}{Final Year Project Link}
\section{Heroku}
\href{https://final-year-project-data-visual.herokuapp.com/}{Heroku Link}
\section{Screencast Link}
\href{}{Screencast Link}

